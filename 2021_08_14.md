# 중간 평가

### 정리 내용

# [ 질문 나올 것 ]

- production, development 왜 다르게 안했는지?

- redux-toolkit 어떻게 찾았는지?

    리덕스를 라이브러리없이 사용할때 액션타입정의 → 액션함수 정의 → 리듀서 정의를 하고 1개액션을 생성해서 써야되고 불변성 때문에
    immer를 쓰고 store값 핸들링할려고 reselect를 쓰고 thunk 미들웨어까지 설치해서 써야되는데 toolkit은 위 기능들을 전부 지원하기 때문에 안쓸 이유가 없음.

- 왜 문제들을 서버 db에 넣지 않고 프론트에서 관리하는지?

    바뀌는 값이 없기도 하고 한문제 넘어갈때마다 api요청을 보내고 받아오게되면 불필요한 요청이 너무 많아지게 되기도 하고 프론트에서 바로 객체로 만들어서 쓰는게 속도도 훨씬 빨라서 프론트에서 관리하게 됨

- Why Express

    **express**: 낮은 러닝커브와 단순한 아키텍쳐에도 불과하고 압도적인 사용자 수로 인한 각종 사례의 풍부함. 

    물론 메모리 사용량이 높다는 단점과 단순하기에 다른 프레임워크와 달린 확장성이 제한적임

    **NestJs**: typescript 사용 용이 및 dependeny injection 등 확장성이 높지만 러닝 커브가 심)

    **koa:** 근복적으로  express와 같은 설계를 가짐, 사용자의 사례가 비교적 적지만 async-await 사용 용이나 try - catch 처리 불필요 등 express의 단점을 커버

- Why Typescript

    코드에 목적을 명시하고 목적에 맞지 않는 타입의 변수나 함수들에서 에러를 발생시켜 버그를 사전에 제거합니다. 또한 코드 자동완성이나 실행 전 피드백을 제공하여 작업과 동시에 디버깅이 가능해 생산성을 높일 수 있습니다.

- Why Jest

    Jest의 가장 큰 장점은 쉬운 설치 및 사용 방법. 별다른 추가 설치 없이 테스트에 필요한 모든 기능을 사용할 수 있음

- Why Swagger

    Restful API의 문서화, 간단한 JSON 형태로 틀을 만들어주면 웹 페이지에 시각화해서 나타내며 API 테스트까지 가능하다.

    하지만, 우리 조에서는 유용하게 사용하지 않음,

    아무리 좋은 라이브러리라도 계속 관리해주지 않으면 무용지물

    협업툴로서 모두가 알아야함, 이러 측면에서 관리가 미흡했다고 생각.

- Why Mongo & Atlas & Mongoose (ODM)
    - **Mongo DB를 선택한 이유**
        1. 우리 ohsool같은 경우는 사용자가 user 한명이기 때문에 복잡한 관계형 데이터베이스가 필요하지 않았다. 
        2. 또한, 개발단계에서 기능들이 계속해서 추가되고 있는 단계였기 때문에 유연하게 확장시킬 수 있는 NoSQL DB가 적합하다고 판단하여 Mongo DB를 사용하고 있다.
    - **NoSQL vs SQL**

        NoSQL: 

        비정형 관계로 없기에 다른 구조(schema)의 데이터를 하나의 테이블에 추가할 수 있다. 

        SQL Join과 비슷하게 하기 위해선 데이터를 복제하여 다른 테이블 데이터에 속하는 방식을 사용하는데, 이런한 특징은 데이터 중복성을 높일수도 있지만

        추가 테이블을 생성할 때 복잡한 Join없이 데이터 베이스를 유연하게 확장할 수 있다는 장점이 있다.

        또한, 수평적 확장을 지원하는데, MongoDB같은 경우는 기본적으로 3개의 Replica Set을 지원하고 있어 failover(장애 조치)를 할 수 있다.

        SQL: 

        정해진 Schema에 따라 데이터 저장, 

        관계를 통해 여러개의 테이블에 분산. 

        테이블을 여러개의 테이블로 나눌 수 있어 중복을 피할 수 있으며 더 정확한 데이터를 추출할 수 있다.

    - **Atlas (DBaaS)를 선택한 이유**(Dastabase as a Service)

        > DBaaS란, 클라우드 환경(가상화 환경)에 준비한 DB를 네트워크를 통해 제공하는 서비스

        > VPC란, **Virtual Private Cloud** 의 약자이며 EC2의 네트워킹 계층. 
        AWS Cloud를 프로비저닝 (사용자 요구에 맞게 시스템 자원을 할당)하여 사용자가 정의한 가상 네트워크로 AWS 리소스를 함께 사용 가능. 
        IP 주소 범위, 서브넷 등 가상 네트워킹 환경을 제어 가능

        1. 기본 제공 크기 - 500MB
        2. Mongoose같은 ODM과 잘 연동되며 관리가 간단함
        3. 강력한 보안
            - Amazon VPC를 이용한 네트워크 분리
            - IP whitelists, encryption of data in-flight using TLS/SSL
        4. Mongo DB에서 자체적으로 제공하는 서비스
    - **Mongoose를 선택한 이유**

        > Mongoose란, Nodejs와 MongoDB를 위한 ODM (Object Data Mapping) 라이브러리

- Why AWS CI
- Why JWT
- What library

    -react-step-progress-bar : 단계별 입력 확인용. 입력 값을 애니메이션 효과 적용한 프로그래스바로 처리하기 위함 (progressbar, step) 내부적인 position은 백분율로 적용하기때문에 DB에 저장시 별점인 1~5점으로 변환 

    -react-chartjs-2 : 레이더 차트로 그래프를 보여주기 위함. 여러 그래프 차트중 자유도가 가장 높아 원하는 결과 값을 보여주기 적합(label, score)

    -react-slick : 카테고리 로테이터용. 8개의 카테고리 및 all 모바일 뷰에서 효율적으로 보여주기 위해 적용 (infinity,speed,한번에 보여줄 양)

- What style

    styled-components가 컴포넌트 내에서 바로바로 스타일을 변경할 수 있기 때문에 좀더 빠르게 변경사항을 반영 할 수 있다. 그리고 인라인 보다는 가독성측면에서 훨씬 보기 좋음.

    scss를 사용했고, 일부는 css파일을 만들어 스타일 적용하기도함

- DB 서버와 web 서버를 분리한 이유

    **2. Scale-out 시 문제점**

    위의 경우처럼 서버의 사용률이 높아서 과부하가 걸릴 때에는 서버의 증설을 고려할 수 있다.

    DB서버를 분리하지 않고 Web Server, WAS, DB서버를 모두 증설한다 ? 이것이 문제가 될 수 있다.

    Web Server의 부하가 생기면 단순히 수를 늘리고 L4와 같은 부하분산장비로 처리하면 문제가 해결되겠지만,

    DB의 경우에는 이런 확장 및 증설이 어렵고 돈도 돈대로 나간다.

    따라서 사용자가 많은 웹서비스의 경우 DB서버를 분리하여 고가, 고성능의 DB서버 한두개를 운영한 뒤

    저가의 Web Server를 여러개 운영하고 이 웹서버들이 하나의 DB서버를 바라보는 식의 서비스를 하는 경우가 많다.

    **3. DB서버는 메모리에 의존적이다.**

    DB는 (web server에 비해) 거의 메모리에 의존적이다.

    설정에 따라 다르지만 DB 서버를 여러개 운영할 경우에 DB에 물리 메모리의 80% 이상을 할당하도록 권고하고 있다고 한다.

    사용률이 많은 서버를 운영 할 때,

    이런 상황에서 WEB과 DB를 함께 운영하게 되면 메모리 자원이 부족한 현상을 겪게 된다.

    출처:

    [https://alkhwa-113.tistory.com/entry/Web-Server와-DB를-분리하는-이유](https://alkhwa-113.tistory.com/entry/Web-Server%EC%99%80-DB%EB%A5%BC-%EB%B6%84%EB%A6%AC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)

    [기(술) 블로그]

## architecture 설명

<img width="1231" alt="Screen Shot 2021-08-16 at 9 16 30 PM" src="https://user-images.githubusercontent.com/62330320/129562344-cfbd556a-28a3-4520-a039-7ef927b84a16.png">
<img width="1056" alt="Screen Shot 2021-08-16 at 9 16 37 PM" src="https://user-images.githubusercontent.com/62330320/129562361-22780a5e-0463-433d-ad2a-36db2388e7df.png">


S3: 웹 데이터 저장소 / S3 bucket: 웹 서버. S3 컨테이너. 

이후에 AWS load balancer와 auto scaling group을 이용하여 트래픽 최적화 진행 예정
<img width="1228" alt="Screen Shot 2021-08-16 at 9 16 47 PM" src="https://user-images.githubusercontent.com/62330320/129562385-417903d0-a1a4-44eb-bb33-2883451fbc62.png">


## **CI/CD 용어 정리**

**CodePipeline**

- 코드를 지속적으로 제공하는 파이프라인 구축
- 소프트웨어 배포에 필요한 단계를 모델링, 시각화 및 자동화하는데 사용할 수 있는 지속적인 제공 서비스
- 코드를 실제 production 환경에 전달하기 전 파이프라인 프로세스로 통합한다.

**CodeBuild (테스트코드)**

- 애플리케이션 코드를 빌드 및 테스트하기 위해 사용된다.
- 소스 코드를 컴파일 및 테스트를 진행하며 배포 준비가 되도록 소프트웨어 패키지를 관리한다.

**CodeDeploy**

- 코드를 EC2에 배포한다.
- EC2 인스턴스, 서버리스 Lambda 기능에 대한 배포를 자동화하는 서비스이다.

## 정리

1. **organization 만들어서 백/프론트가 따로 repository 소유**
    - 백: 개인 브랜치 각각 3개 → dev → master(개발브랜치) (배포용 브랜치)
    - 프론트: 개인 브랜치 각각 2개 → develop → master (최종 브랜치)

    git commit rule: [수정자] <type> commit message in english

    master 브랜치에서 작업용 개인 브랜치를 생성한다.

    <img width="721" alt="Screen Shot 2021-08-16 at 9 17 13 PM" src="https://user-images.githubusercontent.com/62330320/129562447-c2724bbc-b200-4ee9-80cf-61ebd76ee2e4.png">

    <몰입>, <이 순간에 최선>이 그냥 저의 전부였습니다. - 문진영, 윤송 

2. 보안
    - **https ⭐️**

    : 현재는 백엔드 도메인에만 https 적용. 프론트는 현재 위치 가져오기, pwa 적용하면서 https 적용 예정. 

    - **secret key**

    : 프론트, 백이 약속한 특정 secret key는 정각마다 바뀜. 원래 백 도메인 뒤에 값을 넣으려고 했으나 시간마다 바뀌려면 서버가 꺼졌다 켜져야 하는 2~3초의 위험을 감수할 수 없어 클라이언트는 모든 API 접근시 헤더에 정각마다 바뀌는 secret key 얹어서 보냄. 단, 백엔드 서버 안에서 이루어져야 하는 callback url에 대해서는 secret key를 검사하지 않음.

    - **슬랙 연동 토큰 값 → env ⭐️**

    : 슬랙 webhook을 사용하려면 OAuth Token을 코드에 작성해야 하는데 github에 올리면 token이 publish 되었다며 토큰 사용이 비활성화. 그 외에 감춰야 하는 id, pw, secret 값들이 있어야하는데 master 브랜치에 올려야만 배포가 되는 문제에 직면하여 env 사용하게 됨. 그리고 프로세스별로 다르게 돌아가는 환경(production, development, test, local) 설정을 위해 dotenv 라이브러리 사용. 이 때문에 db, port를 상황에 따라 구분하여 사용 가능

    - **jwt**

    : HTTP 헤더를 통해 암호화된 토큰을 전달하여 cookie에 저장, 유저 권한 인증 확인을 할 수 있다. 

    session: 보안에는 더 좋지만 페이지 나갈 때마다 사라짐.

    cookie: 속도 빨라짐

    토큰은 시크릿키와 userId를 이용하여 생성하고 프런트에서는 해당 토큰값을 한번 복호화하여 나온 userId를 통해 유저의 정보를 확인한다.

    로그인 인증에 JWT를 선택한 이유는 session, cookie와는 다르게 별도 저장소가 필요하지 않고 서버와 클라이언트에서 검증만 진행하면 되기 때문에 보관에 용이하며

    서버에 과부하를 줄일 수 있다.

    또한, 클라이언트에 값이 저장되는 것이 아니기 때문에 http 요청을 탈취당할 때에 사용자 정보 유출을 예방할 수 있다. (?)

3. 기능
    - **테스트 result 보여주는 작업 ⭐️**

    : 프론트에서 문제들을 key, value 오브젝트 형태의 데이터로 관리. 1번 문제 이후에 바로 2번 문제가 아닌, 전 답변에 따라 다음 문제가 달라지는 형태. 서버 db에 담지 않은 이유는 한 문제마다 서버랑 통신하는 것이 불필요하기 때문. 텍스트밖에 없고, 다음 문제로 넘어갈 때 프론트에서 관리하면 더 빠름. 결과값만 서버에 전달해주면 서버가 그에 맞는 beerCategory 추천 맥주를 보내준다

    - **맥주도감 작성, 수정, 삭제시 avgRate에 적용 (그 당시의 preference) ⭐️**

    : 테스트 결과 라거 타입이면 user정보에 라거타입이라는 preference(유저의 맥주 카테고리 취향)가 담김. 맥주도감을 적는 당시의 preference를 category의 평점에 반영함. 해당 맥주가 Lager인데 나의 preference가 Stout라면 Lager의 평점 전부가 아닌 그 중 Stout가 주는 평점에만 영향을 미침. 이 결과값들은 데이터들이 많이 모이게 되면 어떤 취향을 가진 유저가 어느 취향을 좋아하고, 어느 취향을 싫어하는지에 대한 정보가 나올 수 있음.

    - **장소 제보하기 ⭐️**
        - kakao map, 현재 위치 -> https 적용할 예정

    : 로그인한 유저는 한 맥주에 대해 어디서 구매하였는지 장소 제보가 가능. 제보의 정확성을 위하여 동일한 유저가 한 맥주에 대해 같은 곳을 제보할 수 없도록 설계. 다른 유저들이 한 맥주를 똑같은 곳에서 샀다는 제보가 3건 들어오면 정말 판다고 판단, 실제로 서버에서 사용하는 정보가 됨.

    - **검색 ⭐️**

    : 검색 기능은 영어로는 만들기는 쉬우나 한국어는 초성, 중성, 종성이 있어서 복잡. 'ㅁ'만 쳐도 '밀러'가 나와야 하기 때문에 한국어 정규식을 사용. 철자 하나만 입력해도 검색이 된다. 검색어와 모든 db 값들을 비교. 모두 띄어쓰기를 제거하고 검색. 영어는 모두 소문자로 변경하여 검색.

4. 기타
    - **구조화를 이용한 MVC 패턴 구현**

    : 비즈니스 로직을 분리하여 로직을 추상화, 캡슐화. 유지보수가 쉽고 협업이 가능한 **효율적**인 코드 작성 및 불필요한 코드를 최대한 제거.

    - **효율성 극대화**
    - **redux-toolkit ⭐️**

    : redux 라이브러리. extrareducer: api 요청들을 한번에 여러개 보내놓고 오는 순서대로 처리하는 메소드. 비동기 api 요청작업 수행. reselect 이용으로 Selector 컴포넌트에서 재실행 방지. 이로써 효율성이 극대화. **상태관리**

    - **react.memo**

    : 여러개 컴포넌트 중에 하나의 값만 바뀌면 그 부분만 재렌더링. 불필요한 렌더링 방지. **컴포넌트 최적화**

    - **브라우저 호환성 테스트 예정**

    : 현재는 크롬, 사파리에만 호환. 이후 파이어폭스, 삼성인터넷, 네이버 웨일의 호환성도 테스트 예정

    - **테스트시 local DB 사용**

    : 현재 db는 서버와 떨어져있음. 값을 가져오는데 시간이 너무 오래 걸리기 때문에 테스트코드 진행시 시간이 너무 오래 걸림. 그래서 테스트 진행 때는 서버와 같은 기준을 가진 local db를 사용함으로써 시간적 효율성을 극대화. **jest를 이용한 TDD 진행**

    - 테스트 코드 사용 시 오류를 100% 방지할 수는 없지만 작은 불씨일 때부터 진압이 가능하다는 장점이 있음 (예: avgRate 의 소수점이 예상한 값과 다르다는 걸 테스트 코드를 통해 파악했음)
    - **그래프**: **react-chartjs-2**, rechart(자유도가 떨어짐), react-svg-radar-chart
    - **무한스크롤 개복치**

    : 밑에 도달했을 때 함수 실행 X, throttle 0.3초 대기, 로딩중일때 함수 실행 못하게 막아놓음

    Throttle: 어떤 함수 실행할 때 대기 시간 줌 (스크롤 제어할 때) / Debounce: 시간차 간격으로 수행할 때 (검색할 때)

      
     
# 발표 영상
https://www.youtube.com/watch?v=e_DbG9qmWHQ



